# 🔎 LangChain의 Chain 
## 1. Chain이란?

* **정의**: LangChain에서 **LLM, 프롬프트, 도구, 메모리 등을 연결해 워크플로우를 만드는 구조**.
* **핵심 목적**: 단순 1회 질문→응답을 넘어, **여러 단계를 체계적으로 연결해 복잡한 작업 수행**.
* **비유**: 리포트를 쓸 때 “자료 수집 → 요약 → 분석 → 결론” 단계를 순서대로 묶어 실행하는 것.

---

## 2. 왜 Chain이 중요한가?

1. **복잡한 프로세스 처리**: 검색, 요약, 분석 등을 조합.
2. **재사용성**: 동일한 패턴을 Chain으로 만들어 재활용.
3. **결과 품질 관리**: 다양한 출력 전략(Map-Reduce 등)으로 결과 정확성 강화.

---

## 3. Chain의 기본 구조

1. **Input**: 질문, 데이터
2. **Prompt Template**: 입력을 프롬프트로 변환
3. **LLM 호출**: 모델 실행
4. **Output 방식 선택**: 단순 출력, 요약, Map-Reduce, Refine 등

---

## 4. Chain의 종류

* **LLMChain**: 기본 프롬프트-LLM-출력 흐름
* **SequentialChain**: 여러 Chain을 순서대로 실행
* **RouterChain**: 입력 조건에 따라 다른 Chain 실행
* **RetrievalQA Chain**: 벡터 검색 + LLM 결합 (RAG 구현 핵심)
* **APIChain**: API 호출 자동화

---

## 5. 결과 도출 방식 (Output Strategies)

LangChain에서 긴 문서나 여러 Chunk를 다룰 때 대표적으로 사용하는 방식은 다음과 같습니다:

### (1) Stuff (단순 삽입 방식)

* 모든 문서를 한 번에 프롬프트에 넣고 답변 생성.
* **장점**: 구현 간단, 문맥 풍부.
* **단점**: 문서가 길면 토큰 초과 위험.
* **적합한 경우**: 짧은 문서 요약, 작은 데이터셋 QA.

![images](https://github.com/KoreaEva/HOL/raw/master/AzureOpenAI/part2%20RAG/images/09.stuff.jpg)

---

### (2) Map-Reduce

* **Map 단계**: 각 Chunk(문단)에 대해 부분 답변/요약 생성.
* **Reduce 단계**: Map 결과들을 모아 최종 요약 또는 결론 생성.
* **장점**: 대규모 문서 처리 가능, 확장성 높음.
* **단점**: Reduce 과정에서 세부 정보 일부 손실 가능.
* **적합한 경우**: 긴 보고서 요약, 수천 페이지 문서 처리.

![images](https://github.com/KoreaEva/HOL/raw/master/AzureOpenAI/part2%20RAG/images/10.map_reduce.jpg)

---

### (3) Refine (점진적 개선 방식)

* 처음 Chunk를 바탕으로 초기 답변 생성 → 이후 Chunk를 순차적으로 보며 답변을 점진적으로 업데이트.
* **장점**: 맥락을 누적 반영, 더 정교한 답변.
* **단점**: 시간이 오래 걸리고 비용이 증가.
* **적합한 경우**: 분석적 문서 요약, 정확성 중요한 QA.

![images](https://github.com/KoreaEva/HOL/raw/master/AzureOpenAI/part2%20RAG/images/11.refine.jpg)

---

### (4) Map-Rerank

* **Map 단계**: 각 Chunk에 대해 독립적으로 답변과 “점수(score)”를 생성.
* **Rerank 단계**: 가장 점수가 높은 답변을 선택.
* **장점**: 정답 가능성이 높은 응답 선택 가능.
* **단점**: 계산량 많음, 일부 정보 무시될 수 있음.
* **적합한 경우**: 단일 정답이 필요한 질의응답.

![images](https://github.com/KoreaEva/HOL/raw/master/AzureOpenAI/part2%20RAG/images/12.map_rerank.jpg)

---

## 6. 방식별 비교

| 방식         | 특징            | 장점             | 단점       | 적합한 사례    |
| ---------- | ------------- | -------------- | -------- | --------- |
| Stuff      | 모든 문서 통째 입력   | 간단, 문맥 풍부      | 토큰 초과 위험 | 짧은 문서     |
| Map-Reduce | 분할 처리 후 합치기   | 확장성, 대규모 문서 처리 | 세부 손실 가능 | 긴 보고서 요약  |
| Refine     | 점진적 업데이트      | 정밀한 답변         | 느리고 비용↑  | 법률, 연구 분석 |
| Map-Rerank | 답변+점수 후 최적 선택 | 정답률↑           | 계산량↑     | 단일 정답 QA  |

---

## 7. Chain의 장점

* 복잡한 데이터 처리 가능
* 다양한 출력 전략 선택 가능 (Stuff, Map-Reduce, Refine, Map-Rerank)
* 모듈화 및 재사용성

---

## 8. Chain의 한계

* 단계가 늘어날수록 속도·비용 부담
* 출력 품질이 LLM 성능에 의존
* 잘못된 Chunk 처리 시 최종 결과 왜곡 가능

---

## 9. Chain 활용 사례

* **문서 요약 시스템**: 긴 보고서를 Map-Reduce로 요약
* **QA 챗봇**: Refine 방식으로 맥락 보강
* **연구 분석 도구**: Stuff + Refine 결합
* **정확성 중요한 질의응답**: Map-Rerank로 최적 답변 선택

---

## 10. 앞으로의 발전 방향

* **Adaptive Strategies**: 질문 성격에 따라 Stuff/Map-Reduce/Refine 자동 선택
* **멀티모달 Chain**: 텍스트+이미지+오디오 함께 요약
* **Self-Optimizing Chain**: 모델이 스스로 최적의 Output 방식 결정

---

👉 정리하면, \*\*LangChain의 Chain은 “LLM 활용 워크플로우를 구성하는 설계자”\*\*이고,
결과는 **Stuff, Map-Reduce, Refine, Map-Rerank** 같은 전략을 통해 도출할 수 있습니다.
즉, Chain은 단순 연결을 넘어서 **긴 문서와 복잡한 문제를 처리할 수 있는 Output 엔진** 역할을 합니다.